///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
///
///
///
///
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma once

#include <string>
#include <queue>
#include <condition_variable>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Implements a semaphore for queue input
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class QueueInputSema4
{
private:
    std::mutex mtx;
    std::condition_variable cv;
    int count;

public:
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief      Constructor
    /// @param[in]  count_  startig value for member count
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    QueueInputSema4(int count_ = 0) : count(count_) { ; }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief  Notify function
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void notify()
    {
        std::unique_lock<std::mutex> lck(mtx);
        ++count;
        cv.notify_one();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief  Wait function
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void wait()
    {
        std::unique_lock<std::mutex> lck(mtx);

        while (count == 0)
        {
            cv.wait(lck);
        }
        count--;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief  Wait function
    /// @param[in]  us  the wait time in microseconds
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    int wait_for(uint32_t us)
    {
        std::unique_lock<std::mutex> lck(mtx);

        while (count == 0)
        {
            if (cv.wait_for(lck, std::chrono::microseconds(us)) == std::cv_status::timeout)
            {
                return (-1);
            }
        }
        count--;

        return (0);
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Implements a FIFO queue
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
class FifoQueue
{
public:
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief      Constructor
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FifoQueue() {}

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief      Destructor
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    virtual ~FifoQueue() {}

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief      Put an element to the queue
    /// @param[in]  val     value to put
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void put(T val)
    {
        mMtx.lock();
        mQueue.push(val);
        mMtx.unlock();
        sem.notify();
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief  Get an element of the queue
    /// @return     the element
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    T get()
    {
        sem.wait();

        mMtx.lock();
        T val = mQueue.front();
        mQueue.pop();
        mMtx.unlock();

        return (val);
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief  Get an element of the queue with timeout
    /// @param[in]  ms  the timeout in milliseconds
    /// @return     the element
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    T getWithTimeout(uint32_t ms)
    {
        T val;

        if (sem.wait_for(ms * 1000) == 0)
        {
            mMtx.lock();
            val = mQueue.front();
            mQueue.pop();
            mMtx.unlock();
        }

        return (val);
    }

private:
    std::queue<T> mQueue;

    // hbm mutex
    std::mutex mMtx;
    QueueInputSema4 sem;
};
